// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Post from "./post.bs.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as React from "react";
import * as PostView from "./PostView.bs.js";
import * as Belt_Array from "bs-platform/lib/es6/belt_Array.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as DeletedPost from "./DeletedPost.bs.js";
import * as Belt_MapString from "bs-platform/lib/es6/belt_MapString.js";

function s(prim) {
  return prim;
}

function reducer(state, action) {
  switch (action.TAG | 0) {
    case /* DeleteLater */0 :
        return {
                posts: state.posts,
                forDeletion: Belt_MapString.set(state.forDeletion, action._0.id, action._1)
              };
    case /* DeleteAbort */1 :
        return {
                posts: state.posts,
                forDeletion: Belt_MapString.remove(state.forDeletion, action._0.id)
              };
    case /* DeleteNow */2 :
        var post = action._0;
        return {
                posts: state.posts.filter(function (e) {
                      return Post.id(e) !== post.id;
                    }),
                forDeletion: Belt_MapString.remove(state.forDeletion, post.id)
              };
    
  }
}

var initialState = {
  posts: Post.examples,
  forDeletion: undefined
};

function PostFeed(Props) {
  var match = React.useReducer(reducer, initialState);
  var dispatch = match[1];
  var state = match[0];
  var handleDeleteAbort = function (post, _evt) {
    var timeoutID = Belt_MapString.get(state.forDeletion, Post.id(post));
    if (timeoutID !== undefined) {
      clearTimeout(Caml_option.valFromOption(timeoutID));
    } else {
      console.log("Can't find timeout ID, Post will be deleted or already deleted");
    }
    return Curry._1(dispatch, {
                TAG: /* DeleteAbort */1,
                _0: post
              });
  };
  var handleDeleteNow = function (post, _evt) {
    return Curry._1(dispatch, {
                TAG: /* DeleteNow */2,
                _0: post
              });
  };
  var handleDeleteLater = function (post, _evt) {
    var timeoutId = setTimeout((function (param) {
            return Curry._1(dispatch, {
                        TAG: /* DeleteNow */2,
                        _0: post
                      });
          }), 10000);
    return Curry._1(dispatch, {
                TAG: /* DeleteLater */0,
                _0: post,
                _1: timeoutId
              });
  };
  return React.createElement("div", {
              className: "max-w-3xl mx-auto mt-8 relative"
            }, Belt_Array.map(state.posts, (function (post) {
                    if (Belt_MapString.has(state.forDeletion, post.id)) {
                      return React.createElement(DeletedPost.make, {
                                  post: post,
                                  handleDeleteAbort: handleDeleteAbort,
                                  handleDeleteNow: handleDeleteNow,
                                  key: post.id
                                });
                    } else {
                      return React.createElement(PostView.make, {
                                  post: post,
                                  handleDeleteLater: handleDeleteLater,
                                  key: post.id
                                });
                    }
                  })));
}

var make = PostFeed;

export {
  s ,
  reducer ,
  initialState ,
  make ,
  
}
/* Post Not a pure module */
